# Cursor-Based-Pagination
## Introduction
The pagination concept refers to breaking down large sets of data into small bits so that it can easily be useful to both the application and the user. A good example is when searching for something in Google. Google populates results on a page then breaks the results down to multiple pages depending on the keywords used. This is a breakdown of the multiple millions of results Google has found for the query. It breaks them down so that it is easy for the user to browse through (the process referred to as pagination or organizing data into pages). In pagination, users can move sequentially, from the first page through the pages all the way to the last page.

*Pagination Example*

<p align="center">
  <img width="220" height="110" src="https://github.com/DavidMwihuri39/cursor-based-pagination/blob/main/example_1.png">
</p>


## Limit/Offset pagination
At times, users face the challenge of fetching a huge number of records from a database. This causes a big problems especially in the cases where the records run into the thousands and cannot be queried by a simple select query. In this case, the concept of pagination is used where rather than taking records in large quantities at one go, the concept of taking limit and offset values to fetch records in small quantities and process them until all are retrieved from the database is used.

## Cursor-based pagination
A cursor refers to a unique identifier for a definite record acting as a pointer to the following record the user wants to start querying to get the next results. When a cursor is implemented, the need to read rows that already been viewed is eliminated using a WHERE clause in the query which accelerates the process of reading data. This helps remove   inaccuracies in results by reading after a precise row rather than depending on the records position to be unchanged.
*Example* 
   
   ```
      Post
	|> order_by (inserted_at: :desc)
	
	|> limit (10)
	
	|> where [p], p.id , ^cursor
```
## Comparing Limit and Cursor Based pagination
Though cursor based pagination is considered to be more effective, limit based pagination is the easier one to implement especially in cases where data is static. In addition, as limit based incorporate a mechanism of infinite scroll, it is considered efficient whereby the users can see most of the data at a go. 
Cursor based pagination in its part is more effective on its part as a result of various reasons. The very first of this is that instead of sending an offset parameter with the mannerisms of an index, this mode of pagination sends a cursor parameter which acts like a pointer to a specific record in the database indicating where the last page was set off ensuring no data is left out. In addition, one of the main advantages of this mode of pagination is its ability to perform data capabilities in real time. This is due to cursors not being tied down to static data hence new items can be manipulated without disturbing load procedures on each page.
## User Guide
Using the information above, we can now create a functional pagination example using the following technologies: GraphQL, Prisma, Nexus, Nexus-Prisma, and SQLite. Using these technologies, you can create a server with pagination running in less than 30 minutes. Here is a high-level overview of the steps that will be involved in the process.

1. [Install Prisma](#1-install-prisma)
2. [Initialize Prisma Project and NPM Project](#2-initialize-prisma-project-and-npm-project)
3. [Add Project Scripts](#3-add-project-scripts)
4. [Install Dependencies](#4-install-dependencies)
5. [Create Apollo Server](#5-create-apollo-server)
6. [Generating Schema through GraphQL Nexus](#6-generating-schema-through-graphql-nexus)


### 1. Install Prisma

This installs Prisma in its entirity on your local. From this you can initialize everything you need to do with Prisma through the command line interface.

```
npm install prisma2 -g
```
### 2. Configure Prisma and NPM
Inside the project directory, run the command -- *following the prompt options listed*. This will call the Prisma Framework to open a project. A wizard like sequence will begin. Once Complete, you should now view a new directory called *pagination* inside the folder *Prisma*.
```
npx prisma2 init pagination-example
  - blank project
  - SQLite
  - CoffeeScript
  - Prisma schema
```

In addition, create package.json for the project. You will achieve this by running `npm init -y` inside the directory called *pagination*. The goal here is acting as an interface to add scripts and dependencies.

```
cd pagination-example
npm init -y
```

### 3. Add Project Scripts

In your package.json, project scripts are essential as they are needed to run the Appolo Server and generate the database access client. This is done the first time as subsequent attempts once installation is complete are autogenerated after installation.

```js
"dev": "node ./index.js",
"postinstall": "prisma2 generate"
```

### 4. Install Dependencies

Next, you need to install the required dependencies for the project. **Nexus-prisma** is essential as it provides unique features such as **pagination**.

```
npm install express                   # this is the custome node.js server
npm install apollo-server-express     # this is the custom graphql express server
npm install nexus                     # this is creation of the code-first graphql schema
npm install prisma-nexus              # customary bindings for both prisma and nexus
npm install graphql                   # this is installation of graphql
```
### 5. Create Apollo Server
Build the standard Apollo Server without any special functionalities. Use the code-first approach with GraphQL Nexus to create the schema.

```js
// index.js
const express = require('express');
const { ApolloServer } = require('apollo-server-express');

// you will add GraphQL Nexus schema here in next step

const server = new ApolloServer({ });

const app = express();
server.applyMiddleware({ app });

app.listen({ port: 4000 }, () =>
  console.log(`ðŸš€ Server ready at http://localhost:4000${server.graphqlPath}`)
);
```
### 6. Generating Schema through GraphQL Nexus

Time to build the schema - code-first. Start with the required imports - nexus: to create your GraphQL types & schema; nexus-prisma: provides the bindings between nexus & prisma. 

```js
// 1. imports - index.js
const { objectType, queryType, makeSchema } = require("nexus")
const { nexusPrismaPlugin } = require('nexus-prisma')
const { join } = require('path')
```
      
Next, add the types you wish to expose in your API. The first two types created below is an *objectType* for both User and Post. This publicly exposes the id/email fields for Users and id/title/author for Posts.

```js 
// 2. user/post type - index.js
const User = objectType({
  name: 'User',
  definition(t) { t.model.id(), t.model.email() }
})
const Post = objectType({
  name: 'Post',
  definition(t) { t.model.id(), t.model.title(), t.model.author() }
})
```

Next, create a root Query using *queryType*, to start exposing queries, beginning with the posts query. Thanks to Photon and Nexus-Prisma, you have out-of-the-box for pagination and can implement it in as few lines as shown below. You have now exposed a "posts" query that can handle pagination.

```js 
// 3. query type - index.js
const Query = queryType({
  definition(t) {
    t.crud.posts({ pagination: true })
  }
});
```

Next, you create a schema using *makeSchema*, which includes your types, the nexus-prisma plugin and an outputs object. This combines all of the above types into a GraphQL Schema.

```js
// 4. create schema - index.js
const schema = makeSchema({
  types: [Query, User, Post],
  plugins: [nexusPrismaPlugin()],
  outputs: {
    typegen: join(
      __dirname,
      '../node_modules/@types/nexus-typegen/index.d.ts',
    ),
  },
});
```

Finally, you need to update the ApolloServer constructor to include the schema and photon instance. Your Photon instance is now available via the context argument.

```js
// 5. pass schema/photon - index.js
const server = new ApolloServer({ schema, context: { photon } })
```
